<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Manager</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>File Manager</h1>

        <!-- Login Section -->
        <div class="user-info">
            Logged in as: {{ current_user.id }}
            <a href="{{ url_for('logout') }}">
                <button class="logout">Logout</button>
            </a>
        </div>
        
        <!-- Flash messages -->
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="messages">
                    {% for category, message in messages %}
                        <div class="alert {{ category }}">{{ message }}</div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
        
        <!-- Upload Section -->
        <div class="card">
            <h2>Upload Files</h2>
            <form id="uploadForm" method="POST" action="/upload" enctype="multipart/form-data">
                <input type="file" id="fileInput" name="files" multiple required>
                
                <!-- File System Access API Button (if supported) -->
                <div id="fsaContainer" style="display: none; margin: 10px 0;">
                    <button type="button" id="fsaButton" class="secondary-button">
                        üìÅ Select Files (with auto-delete capability)
                    </button>
                    <p class="checkbox-hint">Uses advanced file picker that can automatically delete files after upload</p>
                </div>
                
                <div class="checkbox-container">
                    <label class="checkbox-label">
                        <input type="checkbox" id="deleteAfterUpload" name="deleteAfterUpload">
                        <span>Delete files from device after successful upload</span>
                    </label>
                    <p class="checkbox-hint">Files will only be deleted after verifying upload integrity</p>
                </div>
                
                <button type="submit" id="uploadButton">Upload</button>
                
                <div id="uploadProgress" class="upload-progress" style="display: none;">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <p id="progressText">Uploading...</p>
                </div>
            </form>
        </div>
        
        <!-- File Gallery by Date -->
        <div class="card">
            <h2>üìÅ Stored Files ({{ total_files }} total)</h2>
            
            {% for group in date_groups %}
                <div class="date-group">
                    <div class="date-header">
                        <h3>üìÖ {{ group.date.strftime('%B %d, %Y') }}</h3>
                        <span class="file-count">{{ group.count }} file{{ 's' if group.count != 1 else '' }}</span>
                    </div>
                    
                    <div class="gallery">
                        {% for file in group.files %}
                            <div class="image-card">
                                <!-- 1. File Display -->
                                <div class="image-container {% if file.type != 'image' %}non-image{% endif %}">
                                    {% if file.type == 'image' %}
                                        <img src="{{ url_for('serve_thumbnail', filename=file.name) }}" 
                                            alt="{{ file.name }}"
                                            data-fullsize="{{ url_for('serve_file', filename=file.name) }}">
                                    {% else %}
                                        <div class="file-icon-wrapper">
                                            {% if file.type == 'document' %}
                                                <i class="fas fa-file-alt file-icon-large"></i>
                                            {% elif file.type == 'spreadsheet' %}
                                                <i class="fas fa-file-excel file-icon-large"></i>
                                            {% elif file.type == 'presentation' %}
                                                <i class="fas fa-file-powerpoint file-icon-large"></i>
                                            {% elif file.type == 'archive' %}
                                                <i class="fas fa-file-archive file-icon-large"></i>
                                            {% elif file.type == 'audio' %}
                                                <i class="fas fa-file-audio file-icon-large"></i>
                                            {% elif file.type == 'video' %}
                                                <i class="fas fa-file-video file-icon-large"></i>
                                            {% elif file.type == 'code' %}
                                                <i class="fas fa-file-code file-icon-large"></i>
                                            {% else %}
                                                <i class="fas fa-file file-icon-large"></i>
                                            {% endif %}
                                            <div class="file-extension">{{ file.name.split('.')[-1]|upper }}</div>
                                        </div>
                                    {% endif %}

                                    <!-- Delete Button -->
                                    <a class="delete-icon" href="{{ url_for('delete_file', filename=file.name) }}" 
                                        onclick="return confirm('Permanently delete \'{{ file.name }}\'?')">
                                        <i class="fa fa-trash" aria-hidden="true"></i>
                                    </a>
                                </div>

                                <!-- 2. File Information & Actions -->
                                <div class="image-info">
                                    <!-- 2a. Filename Link -->
                                    <a href="{{ url_for('serve_file', filename=file.name) }}" target="_blank">
                                        {{ file.name }}
                                    </a>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            {% else %}
                <p>No files uploaded yet</p>
            {% endfor %}
        </div>
        <!-- Add pagination controls after gallery -->
        {% if total_pages > 1 %}
        <div class="pagination">
            {% if page > 1 %}
                <a href="{{ url_for('index', page=page-1) }}">‚Üê Previous Dates</a>
            {% endif %}

            <span>Page {{ page }} of {{ total_pages }}</span>

            {% if page < total_pages %}
                <a href="{{ url_for('index', page=page+1) }}">Next Dates ‚Üí</a>
            {% endif %}
        </div>
        {% endif %}
    </div>
    <div id="previewModal" class="modal">
        <span class="modal-close">&times;</span>
        <img id="modalImage" class="modal-content">
    </div>

    <script>
        // Check if File System Access API is supported
        const supportsFileSystemAccess = 'showOpenFilePicker' in window;
        
        // File hash calculation using CryptoJS (works on all devices)
        async function calculateFileHash(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const wordArray = CryptoJS.lib.WordArray.create(e.target.result);
                        const hash = CryptoJS.SHA256(wordArray).toString();
                        resolve(hash);
                    } catch (error) {
                        console.error('Hash calculation failed:', error);
                        reject(error);
                    }
                };
                reader.onerror = function() {
                    reject(new Error('Failed to read file'));
                };
                reader.readAsArrayBuffer(file);
            });
        }
        
        // Auto-delete files using File System Access API
        async function deleteFilesFromDevice(fileHandles) {
            if (!supportsFileSystemAccess || !fileHandles || fileHandles.length === 0) {
                return { success: false, reason: 'File System Access API not supported' };
            }
            
            let deletedCount = 0;
            const failedFiles = [];
            
            for (const handle of fileHandles) {
                try {
                    await handle.remove();
                    deletedCount++;
                } catch (error) {
                    console.error(`Failed to delete ${handle.name}:`, error);
                    failedFiles.push(handle.name);
                }
            }
            
            return {
                success: deletedCount > 0,
                deletedCount,
                failedFiles,
                total: fileHandles.length
            };
        }

        // Show File System Access API button if supported
        if (supportsFileSystemAccess) {
            document.getElementById('fsaContainer').style.display = 'block';
        }
        
        // Store file handles for deletion
        let selectedFileHandles = [];
        
        // File System Access API file picker
        document.getElementById('fsaButton').addEventListener('click', async function() {
            try {
                const fileHandles = await window.showOpenFilePicker({
                    multiple: true,
                    types: [{
                        description: 'All files',
                        accept: { '*/*': [] }
                    }]
                });
                
                // Convert file handles to File objects for the form
                const files = [];
                selectedFileHandles = [];
                
                for (const handle of fileHandles) {
                    const file = await handle.getFile();
                    files.push(file);
                    selectedFileHandles.push(handle);
                }
                
                // Create a new FileList-like object
                const dt = new DataTransfer();
                files.forEach(file => dt.items.add(file));
                document.getElementById('fileInput').files = dt.files;
                
                // Auto-check the delete checkbox
                document.getElementById('deleteAfterUpload').checked = true;
                
                alert(`Selected ${files.length} file(s) with auto-delete capability`);
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('File selection failed:', error);
                    alert('File selection failed: ' + error.message);
                }
            }
        });
        
        // Handle form submission with hash verification
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            const deleteAfterUpload = document.getElementById('deleteAfterUpload').checked;
            
            // If delete option is not checked, use normal form submission
            if (!deleteAfterUpload) {
                selectedFileHandles = []; // Clear handles
                return true;
            }
            
            // Prevent default form submission for AJAX upload
            e.preventDefault();
            
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            
            if (files.length === 0) {
                alert('Please select files to upload');
                return false;
            }
            
            const uploadButton = document.getElementById('uploadButton');
            const uploadProgress = document.getElementById('uploadProgress');
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');
            
            // Disable upload button and show progress
            uploadButton.disabled = true;
            uploadProgress.style.display = 'block';
            
            try {
                // Calculate hashes for all files using CryptoJS
                progressText.textContent = 'Calculating file hashes...';
                const fileHashes = new Map();
                let useHashVerification = true;
                
                try {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        progressText.textContent = `Calculating hash for ${file.name} (${i + 1}/${files.length})...`;
                        const hash = await calculateFileHash(file);
                        fileHashes.set(file.name, hash);
                    }
                } catch (error) {
                    console.error('Hash calculation failed:', error);
                    useHashVerification = false;
                    progressText.textContent = 'Hash verification failed, continuing without verification...';
                }
                
                // Upload files with retry logic
                let allSuccess = true;
                const maxRetries = 3;
                const failedFiles = [];
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    progressText.textContent = `Upload attempt ${attempt}/${maxRetries}...`;
                    progressFill.style.width = '50%';
                    
                    const formData = new FormData();
                    for (let i = 0; i < files.length; i++) {
                        formData.append('files', files[i]);
                    }
                    
                    const response = await fetch('/upload', {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    progressFill.style.width = '75%';
                    
                    // Verify upload success and hashes
                    progressText.textContent = useHashVerification ? 'Verifying file integrity...' : 'Verifying upload success...';
                    
                    allSuccess = true;
                    failedFiles.length = 0;
                    
                    for (const fileResult of result.files) {
                        if (!fileResult.success) {
                            allSuccess = false;
                            failedFiles.push(fileResult.filename);
                            continue;
                        }
                        
                        // Verify hashes if available
                        if (useHashVerification && fileHashes.has(fileResult.filename)) {
                            const clientHash = fileHashes.get(fileResult.filename);
                            const serverHash = fileResult.hash;
                            
                            if (clientHash !== serverHash) {
                                allSuccess = false;
                                failedFiles.push(fileResult.filename);
                                console.error(`Hash mismatch for ${fileResult.filename}`);
                                console.error(`Client: ${clientHash}`);
                                console.error(`Server: ${serverHash}`);
                            }
                        }
                    }
                    
                    if (allSuccess) {
                        progressFill.style.width = '100%';
                        progressText.textContent = useHashVerification ? 
                            'Upload verified! Files can be safely deleted from your device.' :
                            'Upload completed! Files can be safely deleted from your device.';
                        
                        // Auto-delete files if File System Access API was used
                        if (selectedFileHandles.length > 0) {
                            progressText.textContent = 'Deleting files from device...';
                            const deleteResult = await deleteFilesFromDevice(selectedFileHandles);
                            
                            if (deleteResult.success) {
                                const message = `‚úÖ Upload successful!\n\n‚Ä¢ Uploaded: ${files.length} file(s)\n‚Ä¢ Auto-deleted: ${deleteResult.deletedCount} file(s)${deleteResult.failedFiles.length > 0 ? '\n‚Ä¢ Failed to delete: ' + deleteResult.failedFiles.join(', ') : ''}`;
                                setTimeout(() => {
                                    alert(message);
                                    window.location.reload();
                                }, 1000);
                            } else {
                                setTimeout(() => {
                                    alert(`‚úÖ Upload successful!\n\n‚ö†Ô∏è Auto-delete failed: ${deleteResult.reason || 'Unknown error'}\n\nPlease manually delete the files from your device.`);
                                    window.location.reload();
                                }, 1000);
                            }
                        } else {
                            // Show normal success message
                            setTimeout(() => {
                                const message = useHashVerification ? 
                                    `‚úÖ Successfully uploaded and verified ${files.length} file(s).\n\nYou can now safely delete these files from your device.` :
                                    `‚úÖ Successfully uploaded ${files.length} file(s).\n\nYou can now safely delete these files from your device.`;
                                alert(message);
                                window.location.reload();
                            }, 1000);
                        }
                        
                        return;
                    }
                    
                    // If not the last attempt, retry
                    if (attempt < maxRetries) {
                        progressText.textContent = useHashVerification ? 
                            `Hash verification failed for ${failedFiles.length} file(s). Retrying...` :
                            `Upload failed for ${failedFiles.length} file(s). Retrying...`;
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                // All retries failed
                progressFill.style.width = '100%';
                progressFill.style.backgroundColor = '#e74c3c';
                progressText.textContent = '‚ùå Upload verification failed after 3 attempts';
                
                alert(`‚ùå Upload failed after ${maxRetries} attempts.\n\nFailed files:\n${failedFiles.join('\n')}\n\nDO NOT delete these files from your device!`);
                
            } catch (error) {
                console.error('Upload error:', error);
                progressFill.style.width = '100%';
                progressFill.style.backgroundColor = '#e74c3c';
                progressText.textContent = '‚ùå Upload error';
                alert(`‚ùå Upload error: ${error.message}\n\nDO NOT delete files from your device!`);
            } finally {
                uploadButton.disabled = false;
                setTimeout(() => {
                    uploadProgress.style.display = 'none';
                    progressFill.style.width = '0%';
                    progressFill.style.backgroundColor = '#3498db';
                }, 3000);
            }
        });

        // Add confirmation to all delete buttons
        document.querySelectorAll('.delete').forEach(button => {
            button.onclick = function(e) {
                const filename = this.closest('.image-card').querySelector('a').innerText;
                return confirm(`Permanently delete ${filename}?`);
            };
        });

        // NEW: Image preview functionality
        const modal = document.getElementById('previewModal');
        const modalImg = document.getElementById('modalImage');
        const closeBtn = document.querySelector('.modal-close');

        // Open modal with centered image (only for images, not file icons)
        document.querySelectorAll('.image-container:not(.non-image)').forEach(container => {
            container.addEventListener('click', function() {
                const img = this.querySelector('img');
                if (img) {
                    modalImg.src = img.dataset.fullsize;
                    modalImg.classList.remove('zoom'); // Reset zoom state
                    modal.style.display = 'flex'; // Use flex display
                    document.body.style.overflow = 'hidden';
                }
            });
        });

        // Close modal
        closeBtn.addEventListener('click', closeModal);
        window.addEventListener('click', function(event) {
            if (event.target === modal) closeModal();
        });
        
        // Close modal when clicking outside image
        window.addEventListener('click', function(event) {
            if (event.target === modal) {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto';
            }
        });

        // Close with ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && modal.style.display === 'flex') closeModal();
        });

        // New: Toggle zoom on double click/tap
        modalImg.addEventListener('dblclick', function() {
            this.classList.toggle('zoom');
        });

        // New: Mobile pinch-to-zoom simulation
        let lastDistance = 0;
        modalImg.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) lastDistance = getTouchDistance(e);
        });

        modalImg.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                const newDistance = getTouchDistance(e);
                if (newDistance > lastDistance + 10) {
                    this.classList.add('zoom');
                } else if (newDistance < lastDistance - 10) {
                    this.classList.remove('zoom');
                }
                lastDistance = newDistance;
                e.preventDefault();
            }
        });

        function getTouchDistance(e) {
            return Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
        }

        function closeModal() {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

    </script>
</body>
</html>